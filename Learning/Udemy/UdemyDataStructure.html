<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>
    // ** Objects
    // reference type
    //  let object1 = {value:10};
    //  console.log(object1)
    //
    //  let object2 = object1
    //
    //  let object3 = {value:10};
    //
    //  console.log(object1===object2)
    //  console.log(object3)
    // console.log(object1===object3)
    // Context vs scope

    // ** Arrays

    //    const strings = ['a', 'b', 'c', 'd']
    //    // 4*4= 16 bytes of storage
    //    // methods of array
    //    // push
    //    strings.push('e') // 0(1)
    //    strings.pop(); //0(1)
    //    strings.pop(); //0(1)
    //
    //    // add things on front use unshift
    //    // with unshift change the indexes of all elements
    //    // so that's why the Big 0(n)
    //
    //    strings.unshift('x')
    //
    // // //   add and delete thing in the middle use the splice method
    //    strings.splice(2,0,"alien") // 0(n)
    //
    //    console.log(strings)
    //
    //    // //Implementing An array
    //    // class based
    //    class MyArray {
    //        constructor() {
    //            this.length = 0;
    //            this.data = {};
    //        }
    //
    //        get(index) {
    //            return this.data[index]
    //        }
    //
    //        push(item) {
    //            this.data[this.length] = item;
    //            this.length++;
    //            return this.length;
    //        }
    //
    //        pop() {
    //            const lastItem = this.data[this.length - 1]
    //            delete this.data[this.length - 1];
    //            this.length--;
    //            return lastItem;
    //        }
    //
    //        delete(index) {
    //            const item = this.data[index];
    //            this.shiftItems(index)
    //
    //        }
    //
    //        shiftItems(index) {
    //            for (let i = index; i <this.length-1; i++)
    //            {
    //
    //                this.data[i]=this.data[i+1];
    //            }
    //           delete this.data[this.length-1]
    //        }
    //    }
    //
    //    const newArray = new MyArray();
    //    newArray.push("hi")
    //    newArray.push("!")
    //    newArray.push("you")
    //    newArray.push("are")
    //    newArray.push("good")
    //    newArray.push("good")
    //    newArray.delete(1)
    //    console.log(newArray)
    //    newArray.pop()


    // // function based
    //      function MyArray() {
    //          const data = {};
    //          let length = 0;
    //
    //          function get(index) {
    //              return data[index];
    //          }
    //
    //          function push(item) {
    //              data[length] = item;
    //              length++;
    //              return length;
    //          }
    //
    //          return {
    //              get,
    //              push,
    //          };
    //      }
    //
    //      const newArray = MyArray();
    //      newArray.push("hi");
    //      newArray.push("good");
    //      console.log(newArray);

    // //Strings in arrays
    // //reverse array

    //  let str = "hi my name is some"
    //
    //  function reverseString(str) {
    //      // check input
    //      if (!str || str.length < 2 || typeof str !== "string") {
    //          return "That's not string"
    //      }
    //      const backward = [];
    //      const totalItems = str.length - 1;
    //      for (let i = totalItems; i >= 0; i--) {
    //          backward.push(str[i])
    //      }
    //  console.log(backward)
    //      return backward.join('')
    //
    //  }
    //
    //  function reverseString2(str) {
    //      return str.split('').reverse().join("")
    //
    //  }
    //  const reverseString3 = (str) => [...str].reverse().join('')
    //
    //      console.log(reverseString(str))
    //      console.log(reverseString2(str))
    //      console.log(reverseString3(str))
    //
    //  // //second question merge two arrays and sort
    //
    //  function mergeSortedArrays(arr1, arr2) {
    //      let merge = arr1.concat(arr2)
    //      return merge.sort((a, b) => {
    //          return a - b
    //      })
    //  }
    //
    //  console.log(mergeSortedArrays([0, 3, 4, 31], [4, 6, 30]));
    //
    // // // function from the udemy answer
    //      function mergeSortedArrays(array1,array2) {
    //          const mergeArray=[];
    //          let array1Item =array1[0];
    //          let array2Item =array2[0];
    //          let i =1;
    //          let j=1;
    //          // check input
    //          if (array1.length===0){
    //              return array2;
    //          }
    //          if (array2.length===0){
    //              return array1
    //          }
    //          while (array1Item|| array2Item){
    //              console.log(array1Item,array2Item)
    //              if (!array2Item || array1Item<array2Item){
    //                  mergeArray.push(array1Item)
    //                  array1Item=array1[i];
    //                  i++;
    //              }else {
    //                  mergeArray.push(array2Item);
    //                  array2Item=array2[j]
    //                  j++;
    //              }
    //          }
    //          return mergeArray;
    //      }
    //  console.log(mergeSortedArrays([0, 3, 4, 31], [4, 6, 30]))
    //
    //  // some problems on LeetCode
    //  // https://coderbyte.com/editor/Longest%20Word:JavaScript
    //  function twoSum(nums, target) {
    //
    //  }
    //
    //  console.log(twoSum([2, 7, 11, 15], 9))


    // ** Hash tables or Hash maps
    // in JS hash are technically objects

    // let user = {
    //     age: 25,
    //     name: "john",
    //     magic: true,
    //     scream: function () {
    //         console.log("please do that")
    //     }
    // }
    //
    // // implement the hash table
    //
    // function createHashTable(size) {
    //     const data = new Array(size);
    //
    //     function hash(key) {
    //         let hash = 0;
    //         for (let i = 0; i < key.length; i++) {
    //             hash = (hash + key.charCodeAt(i) * i) % data.length;
    //             // console.log(hash,"hash")
    //         }
    //         return hash;
    //     }
    //
    //
    //     function set(key, value) {
    //         const address = hash(key);
    //         // data[address] = [key, value];
    //         // return data.length;
    //         if (!data[address]) {
    //             data[address] = [];
    //             // console.log(data)
    //         }
    //         data[address].push([key, value])
    //         return data //0(1)
    //     }
    //
    //     function get(key) {
    //         const address = hash(key);
    //         // return data[hashedIndex] ? data[hashedIndex][1] : undefined;
    //         const currentBucket = data[address];
    //         // console.log(currentBucket)
    //         if (currentBucket) {
    //             for (let i = 0; i < currentBucket.length; i++) {
    //                 if (currentBucket[i][0] === key) {
    //                     return currentBucket[i][1]
    //                 }
    //             }
    //         } //0(1)
    //         return undefined
    //     }
    // decided to enhance the previous
    // keys() {
    //         if (!this.data.length) {
    //             return undefined
    //         }
    //         let result = []
    //         // loop through all the elements
    //         for (let i = 0; i < this.data.length; i++) {
    //             // if it's not an empty memory cell
    //             if (this.data[i] && this.data[i].length) {
    //                 // but also loop through all the potential collisions
    //                 if (this.data.length > 1) {
    //                     for (let j = 0; j < this.data[i].length; j++) {
    //                         result.push(this.data[i][j][0])
    //                     }
    //                 } else {
    //                     result.push(this.data[i][0])
    //                 }
    //             }
    //         }
    //         return result;
    //     }

    //     function keys() {
    //         const keysArray = [];
    //         for (let i = 0; i < data.length; i++) {
    //             if (data[i]){
    //                 console.log(data[i])
    //                 keysArray.push(data[i][0][1])
    //             }
    //
    //         }
    //         return keysArray
    //     }
    //
    //     return {set, get, keys};
    // }
    //
    // // Usage example:
    //
    // const hashTable = createHashTable(50);
    // console.log(hashTable.set("grapes", 10000));
    // console.log(hashTable.set("apples", 54));
    // console.log(hashTable.set("oranges", 2));
    // console.log(hashTable.get("apples"))
    // console.log(hashTable.keys())

    // Exercise google question
    // given ab array =[2,5,1,2,3,5,1,2,4]
    //In this return the value which is repeated first like in 2 is repeated first it should return 2
    //
    // let array = [2, 5, 1, 2, 3, 5, 1, 2, 4]// It return 2
    // let array2 = [2, 1, 1, 2, 3, 5, 1, 2, 4]//  It should return 1
    // let array3 = [2, 3, 4, 5]// It should return undefined
    // solution with arrays

    // function repeated(input) {
    //     for (let i = 0; i < input.length; i++) {
    //         for (let j = 0; j < i; j++) {
    //             if (input[i] === input[j]) {
    //                 return input[i]
    //             }
    //         }
    //     }
    //     return undefined; //0(n^2)

    // const seen = []; // Array to store seen values
    // for (let i = 0; i < input.length; i++) {
    //     if (seen.includes(input[i])) {
    //         return input[i]; // Return the first repeated value
    //     }
    //     seen.push(input[i]); // Add the value to the seen array
    // }
    // return undefined; //
    // }

    // solution with hash tables

    // function repeated(input) {
    //     let hashMap = {};
    //     for (let i = 0; i < input.length; i++) {
    //         if (hashMap[input[i]] !== undefined) {
    //             return input[i]
    //         } else {
    //             hashMap[input[i]] = i
    //         }
    //         console.log(hashMap)
    //     }
    //     return undefined //0(n)
    // }
    //
    //  console.log(repeated(array))


    // **** Linked list DS

    // const basket =['apples','grapes','pears']

    // linked list diagram:

    // apples
    // 8947-->grapes
    // 8742-->pears
    //372-->null
    // pointer
    // let obj1={a:true};
    // let obj2=obj1; //point same location in the memory
    // obj1.a="some"
    // delete obj1
    // // console.log('1',obj1)
    // console.log('2',obj2)

    // our first linked list
    // 10-->5-->16
    //
    // let myLinkedList = {
    //     head: {
    //         value: 10,
    //         next: {             // reference in memory and  pointer always pointy to the next node
    //             value: 5,
    //             next: {
    //                 value: 16,
    //                 next: null
    //             }
    //         }
    //     }
    // }
    // // singly linkedList
    //  class Node {
    //      constructor(value) {
    //          this.value = value;
    //          this.next = null;
    //      }
    //  }

    // class LinkedList {
    //     constructor(value) {
    //         this.head = {
    //             value: value,
    //             next: null
    //         }
    //         this.tail = this.head
    //         this.length = 1;
    //     }
    //
    //     append(value) {
    //         // const newNode = new Node(value)
    //         const newNode = {
    //             value: value,
    //             next: null
    //         }
    //         this.tail.next = newNode;
    //         this.tail = newNode
    //         this.length++
    //     }
    //
    //     prepend(value) {
    //         const newNode = {
    //             value: value,
    //             next: null
    //         }
    //         newNode.next = this.head;
    //         this.head = newNode
    //         this.length++
    //     }
    //
    //     printList() {
    //         const array = [];
    //         let currentNode = this.head;
    //         while (currentNode !== null) {
    //             array.push(currentNode.value)
    //             currentNode = currentNode.next
    //         }
    //         return array
    //     }
    //
    //     insert(index, value) {
    //         //check params
    //         if (index >= this.length) {
    //             return this.append(value)
    //         }
    //         const newNode = {
    //             value: value,
    //             next: null
    //         };
    //         const leader = this.traverseToIndex(index - 1)
    //         const holdingPointer = leader.next;
    //         leader.next = newNode
    //
    //         newNode.next = holdingPointer;
    //         this.length++
    //         return this.printList()
    //     }
    //
    //     traverseToIndex(index) {
    //         // check params
    //         let counter = 0;
    //         let currentNode = this.head;
    //         while (counter !== index) {
    //             currentNode = currentNode.next;
    //             counter++;
    //         }
    //         return currentNode;
    //     }
    //
    //     remove(index) {
    //         const leader = this.traverseToIndex(index - 1)
    //         const unwantedNode = leader.next;
    //         leader.next = unwantedNode.next;
    //         this.length--
    //         return this.printList()
    //     }
    //
    //     reverse() {
    //         if (!this.head.next) {
    //             return this.head;
    //         }
    //         let first = this.head;
    //         this.tail = this.head
    //         let second = first.next
    //         while (second) {
    //             const temp = second.next
    //             second.next = first
    //             first = second
    //             second = temp
    //         }
    //         this.head.next = null;
    //         this.head = first
    //         return this.printList()
    //     }
    // }

    // const myLinkedList = new LinkedList(10)
    // myLinkedList.append(5)
    // myLinkedList.prepend(255)
    // myLinkedList.append(16)


    // console.log(myLinkedList.insert(2, 99), "insert")
    // console.log(myLinkedList.printList(), "printList")
    // console.log(myLinkedList.remove(3), "remove")

    // console.log(myLinkedList.reverse(), "reverse")
    // console.log(myLinkedList, "LinkedList")
    //     // function based
    //     function createLinkedList(value) {
    //         const linkedList = {
    //             head: {
    //                 value: value,
    //                 next: null
    //             },
    //             tail: null,
    //             length: 1
    //         };
    //
    //         linkedList.append = function (value) {
    //             const newNode = {
    //                 value: value,
    //                 next: null
    //             };
    //
    //             if (!linkedList.tail) {
    //                 linkedList.head.next = newNode;
    //                 linkedList.tail = newNode;
    //             } else {
    //                 linkedList.tail.next = newNode;
    //                 linkedList.tail = newNode;
    //             }
    //
    //             linkedList.length++;
    //         };
    //         linkedList.prepend = function (value) {
    //             const newNode = {
    //                 value: value,
    //                 next: null
    //             };
    //             newNode.next = linkedList.head;
    //             linkedList.head = newNode
    //             linkedList.length++
    //         }
    //         return linkedList;
    //     }
    //
    //     const myLinkedList2 = createLinkedList(10);
    //     myLinkedList2.append(5);
    //     myLinkedList2.append(5);
    //     myLinkedList2.prepend(126);
    // console.log(myLinkedList2);
    //
    // class DoublyLinkedList {
    //     constructor(value) {
    //         this.head = {
    //             value: value,
    //             next: null,
    //             prev: null
    //         }
    //         this.tail = this.head
    //         this.length = 1;
    //     }
    //
    //     append(value) {
    //         const newNode = {
    //             value: value,
    //             next: null,
    //             prev: null
    //         }
    //         newNode.prev = this.tail;
    //         this.tail.next = newNode;
    //         this.tail = newNode
    //         this.length++
    //         return this
    //     }
    //
    //     prepend(value) {
    //         const newNode = {
    //             value: value,
    //             next: null,
    //             prev: null
    //         }
    //         newNode.next = this.head;
    //         this.head.prev = newNode
    //         this.head = newNode
    //         this.length++
    //         return this
    //     }
    //
    //     printList() {
    //         const array = [];
    //         let currentNode = this.head;
    //         while (currentNode !== null) {
    //             array.push(currentNode.value)
    //             currentNode = currentNode.next
    //         }
    //         return array
    //     }
    //
    //     insert(index, value) {
    //         //check params
    //         if (index >= this.length) {
    //             return this.append(value)
    //         }
    //         const newNode = {
    //             value: value,
    //             next: null,
    //             prev: null
    //         };
    //         const leader = this.traverseToIndex(index - 1)
    //         const follower = leader.next;
    //         leader.next = newNode;
    //         newNode.prev = leader;
    //         newNode.next = follower;
    //         follower.prev =newNode
    //         this.length++
    //         console.log(this)
    //         return this.printList()
    //     }
    //
    //     traverseToIndex(index) {
    //         // check params
    //         let counter = 0;
    //         let currentNode = this.head;
    //         while (counter !== index) {
    //             currentNode = currentNode.next;
    //             counter++;
    //         }
    //         return currentNode;
    //     }
    //
    //     remove(index) {
    //         const leader = this.traverseToIndex(index - 1)
    //         const unwantedNode = leader.next;
    //         leader.next = unwantedNode.next;
    //         this.length--
    //         return this.printList()
    //     }
    // }
    //
    // const myLinkedListD = new DoublyLinkedList(10)
    // myLinkedListD.append(5)
    // myLinkedListD.append(16)
    // myLinkedListD.prepend(255)
    // console.log(myLinkedListD.insert(2, 99), "insert")
    // console.log(myLinkedListD.printList(), "printList")
    // console.log(myLinkedListD.remove(3), "remove")
    // console.log(myLinkedListD, "DoublyLinkedList")

    //   // Stack with linked list
    // class Node {
    //     constructor(value) {
    //         this.value = value;
    //         this.next = null;
    //     }
    // }
    //
    // class Stack {
    //     constructor() {
    //         this.top = null;
    //         this.bottom = null;
    //         this.length = 0;
    //     }
    //
    //     peek() {
    //         return this.top;
    //
    //     }
    //
    //     push(value) {
    //         const newNode = new Node(value);
    //         if (this.length === 0) {
    //             this.top = newNode;
    //             this.bottom = newNode;
    //         } else {
    //             const holdingPointer = this.top;
    //             this.top = newNode;
    //             this.top.next = holdingPointer;
    //         }
    //         this.length++
    //         return this
    //     }
    //
    //     pop() {
    //         if (!this.top) {
    //             return null;
    //         }
    //         if (this.top === this.bottom) {
    //             this.bottom = null;
    //         }
    //         this.top = this.top.next;
    //         this.length--;
    //         return this
    //     }
    //
    // }
    //
    // const myStack = new Stack();
    //
    // console.log(myStack.push("google"))
    // console.log(myStack.push("udemy"))
    // console.log(myStack.push("discord"))
    // console.log(myStack.pop())
    // console.log(myStack.peek())

    // function base Stack with linkedList
    // function createNode(value) {
    //     return {
    //         value,
    //         next: null,
    //     };
    // }
    //
    // function createStack() {
    //     let top = null;
    //     let bottom = null;
    //     let length = 0;
    //
    //     function peek() {
    //         return top;
    //     }
    //
    //     function push(value) {
    //         const newNode = createNode(value);
    //         if (length === 0) {
    //             top = newNode;
    //             bottom = newNode;
    //         } else {
    //             const holdingPointer = top;
    //             top = newNode;
    //             top.next = holdingPointer;
    //         }
    //         length++;
    //         return top;
    //     }
    //
    //     function pop() {
    //         if (!top) {
    //             return null;
    //         }
    //         if (top === bottom) {
    //             bottom = null;
    //         }
    //         top = top.next;
    //         length--;
    //         return top;
    //     }
    //
    //     return {
    //         peek,
    //         push,
    //         pop,
    //     };
    // }
    //
    // const myStack = createStack();
    //
    // console.log(myStack.push("google"));
    // console.log(myStack.push("udemy"));
    // console.log(myStack.push("discord"));
    // console.log(myStack.pop());
    // console.log(myStack.peek());

    // Stack implementation with arrays

    // class Stack {
    //     constructor() {
    //         this.array = [];
    //     }
    //
    //     peek() {
    //         return this.array[this.array.length - 1]
    //     }
    //
    //     push(value) {
    //         this.array.push(value)
    //         return this
    //     }
    //
    //     pop() {
    //         this.array.pop()
    //         return this
    //     }
    // }
    //
    // const myStack = new Stack();
    // myStack.push("google")
    // myStack.push("udemy")
    // myStack.push("discord")
    //
    // myStack.pop()
    // myStack.pop()
    // console.log(myStack)
    // console.log(myStack.peek())

    // Queue

    //     class Node {
    //         constructor(value) {
    //             this.value = value;
    //             this.next = null;
    //         }
    //     }
    //
    //     class Queue {
    //         constructor() {
    //             this.first = null;
    //             this.last = null;
    //             this.length = 0;
    //         }
    //
    //         peek() {
    //             return this.first;
    //
    //         }
    //
    //         enqueue(value) {
    //             const newNode = new Node(value);
    //             if (this.length === 0) {
    //                 this.first = newNode;
    //                 this.last = newNode;
    //             } else {
    //
    //                 this.last.next = newNode;
    //                 this.last =newNode;
    //             }
    //             this.length++
    //             return this
    //         }
    //
    //         dequeue() {
    //             if (!this.first) {
    //                 return null;
    //             }
    //             if (this.first === this.last) {
    //                 this.last = null;
    //             }
    //             // const holdingPointer =this.first
    //             this.first = this.first.next;
    //             this.length--;
    //             return this
    //             // return holdingPointer
    //         }
    //
    //     }
    // const  myQueue =new Queue();
    //
    //     myQueue.enqueue("joy")
    //     myQueue.enqueue("Matt")
    //     myQueue.enqueue("Pavel")
    //     myQueue.enqueue("Samir")
    //     console.log(myQueue.peek());
    //     myQueue.dequeue()
    //     myQueue.dequeue()
    //     myQueue.dequeue()
    //     myQueue.dequeue()
    //     console.log(myQueue)

    // Question is implement queue using stacks
    // class CrazyQueue {
    //     constructor() {
    //         this.first = [];
    //         this.last = [];
    //     }
    //
    //     enqueue(value) {
    //         const length = this.first.length;
    //         for (let i = 0; i < length; i++) {
    //             this.last.push(this.first.pop());
    //         }
    //         this.last.push(value);
    //         return this;
    //     }
    //
    //     dequeue() {
    //         const length = this.last.length;
    //         for (let i = 0; i < length; i++) {
    //             this.first.push(this.last.pop());
    //         }
    //         this.first.pop();
    //         return this;
    //     }
    //     peek() {
    //         if (this.last.length > 0) {
    //             return this.last[0];
    //         }
    //         return this.first[this.first.length - 1];
    //     }
    // }
    //
    // const myQueue = new CrazyQueue();
    // myQueue.peek();
    // myQueue.enqueue('Joy');
    // myQueue.enqueue('Matt');
    // myQueue.enqueue('Pavel');
    // myQueue.peek();
    // myQueue.dequeue();
    // // myQueue.dequeue();
    // // myQueue.dequeue();
    // myQueue.peek();
    // console.log(myQueue)


    // Binary Search Tree Iterative

    // class Node {
    //     constructor(value){
    //         this.left = null;
    //         this.right = null;
    //         this.value = value;
    //     }
    // }
    //
    // class BinarySearchTree {
    //     constructor(){
    //         this.root = null;
    //     }
    //     insert(value){
    //         const newNode = new Node(value);
    //         if (this.root === null) {
    //             this.root = newNode;
    //         } else {
    //             let currentNode = this.root;
    //             while(true){
    //                 if(value < currentNode.value){
    //                     //Left
    //                     if(!currentNode.left){
    //                         currentNode.left = newNode;
    //                         return this;
    //                     }
    //                     currentNode = currentNode.left;
    //                 } else {
    //                     //Right
    //                     if(!currentNode.right){
    //                         currentNode.right = newNode;
    //                         return this;
    //                     }
    //                     currentNode = currentNode.right;
    //                 }
    //             }
    //         }
    //     }
    //     lookup(value){
    //         if (!this.root) {
    //             return false;
    //         }
    //         let currentNode = this.root;
    //         while(currentNode){
    //             if(value < currentNode.value){
    //                 currentNode = currentNode.left;
    //             } else if(value > currentNode.value){
    //                 currentNode = currentNode.right;
    //             } else if (currentNode.value === value) {
    //                 return currentNode;
    //             }
    //         }
    //         return null
    //     }
    //     remove(value) {
    //         if (!this.root) {
    //             return false;
    //         }
    //         let currentNode = this.root;
    //         let parentNode = null;
    //         while(currentNode){
    //             if(value < currentNode.value){
    //                 parentNode = currentNode;
    //                 currentNode = currentNode.left;
    //             } else if(value > currentNode.value){
    //                 parentNode = currentNode;
    //                 currentNode = currentNode.right;
    //             } else if (currentNode.value === value) {
    //                 //We have a match, get to work!
    //
    //                 //Option 1: No right child:
    //                 if (currentNode.right === null) {
    //                     if (parentNode === null) {
    //                         this.root = currentNode.left;
    //                     } else {
    //
    //                         //if parent > current value, make current left child a child of parent
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = currentNode.left;
    //
    //                             //if parent < current value, make left child a right child of parent
    //                         } else if(currentNode.value > parentNode.value) {
    //                             parentNode.right = currentNode.left;
    //                         }
    //                     }
    //
    //                     //Option 2: Right child which doesnt have a left child
    //                 } else if (currentNode.right.left === null) {
    //                     if(parentNode === null) {
    //                         this.root = currentNode.left;
    //                     } else {
    //                         currentNode.right.left = currentNode.left;
    //
    //                         //if parent > current, make right child of the left the parent
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = currentNode.right;
    //
    //                             //if parent < current, make right child a right child of the parent
    //                         } else if (currentNode.value > parentNode.value) {
    //                             parentNode.right = currentNode.right;
    //                         }
    //                     }
    //
    //                     //Option 3: Right child that has a left child
    //                 } else {
    //
    //                     //find the Right child's left most child
    //                     let leftmost = currentNode.right.left;
    //                     let leftmostParent = currentNode.right;
    //                     while(leftmost.left !== null) {
    //                         leftmostParent = leftmost;
    //                         leftmost = leftmost.left;
    //                     }
    //
    //                     //Parent's left subtree is now leftmost right subtree
    //                     leftmostParent.left = leftmost.right;
    //                     leftmost.left = currentNode.left;
    //                     leftmost.right = currentNode.right;
    //
    //                     if(parentNode === null) {
    //                         this.root = leftmost;
    //                     } else {
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = leftmost;
    //                         } else if(currentNode.value > parentNode.value) {
    //                             parentNode.right = leftmost;
    //                         }
    //                     }
    //                 }
    //                 return true;
    //             }
    //         }
    //     }
    //     BreadthFirstSearch(){
    //         let currentNode = this.root;
    //         let list = [];
    //         let queue = [];
    //         queue.push(currentNode);
    //
    //         while(queue.length > 0){
    //             currentNode = queue.shift();
    //             list.push(currentNode.value);
    //             if(currentNode.left) {
    //                 queue.push(currentNode.left);
    //             }
    //             if(currentNode.right) {
    //                 queue.push(currentNode.right);
    //             }
    //         }
    //         return list;
    //     }
    // }
    //
    // const tree = new BinarySearchTree();
    // tree.insert(9)
    // tree.insert(4)
    // tree.insert(6)
    // tree.insert(20)
    // tree.insert(170)
    // tree.insert(15)
    // tree.insert(1)
    //
    // console.log('BFS', tree.BreadthFirstSearch());

    //     9
    //  4     20
    //1  6  15  170

    // function traverse(node) {
    //     const tree = { value: node.value };
    //     tree.left = node.left === null ? null : traverse(node.left);
    //     tree.right = node.right === null ? null : traverse(node.right);
    //     return tree;
    // }
    //
    // // Binary Search Tree Recursive
    // class Node {
    //     constructor(value){
    //         this.left = null;
    //         this.right = null;
    //         this.value = value;
    //     }
    // }
    //
    // class BinarySearchTree {
    //     constructor(){
    //         this.root = null;
    //     }
    //     insert(value){
    //         const newNode = new Node(value);
    //         if (this.root === null) {
    //             this.root = newNode;
    //         } else {
    //             let currentNode = this.root;
    //             while(true){
    //                 if(value < currentNode.value){
    //                     //Left
    //                     if(!currentNode.left){
    //                         currentNode.left = newNode;
    //                         return this;
    //                     }
    //                     currentNode = currentNode.left;
    //                 } else {
    //                     //Right
    //                     if(!currentNode.right){
    //                         currentNode.right = newNode;
    //                         return this;
    //                     }
    //                     currentNode = currentNode.right;
    //                 }
    //             }
    //         }
    //     }
    //     lookup(value){
    //         if (!this.root) {
    //             return false;
    //         }
    //         let currentNode = this.root;
    //         while(currentNode){
    //             if(value < currentNode.value){
    //                 currentNode = currentNode.left;
    //             } else if(value > currentNode.value){
    //                 currentNode = currentNode.right;
    //             } else if (currentNode.value === value) {
    //                 return currentNode;
    //             }
    //         }
    //         return null
    //     }
    //     remove(value) {
    //         if (!this.root) {
    //             return false;
    //         }
    //         let currentNode = this.root;
    //         let parentNode = null;
    //         while(currentNode){
    //             if(value < currentNode.value){
    //                 parentNode = currentNode;
    //                 currentNode = currentNode.left;
    //             } else if(value > currentNode.value){
    //                 parentNode = currentNode;
    //                 currentNode = currentNode.right;
    //             } else if (currentNode.value === value) {
    //                 //We have a match, get to work!
    //
    //                 //Option 1: No right child:
    //                 if (currentNode.right === null) {
    //                     if (parentNode === null) {
    //                         this.root = currentNode.left;
    //                     } else {
    //
    //                         //if parent > current value, make current left child a child of parent
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = currentNode.left;
    //
    //                             //if parent < current value, make left child a right child of parent
    //                         } else if(currentNode.value > parentNode.value) {
    //                             parentNode.right = currentNode.left;
    //                         }
    //                     }
    //
    //                     //Option 2: Right child which doesnt have a left child
    //                 } else if (currentNode.right.left === null) {
    //                     if(parentNode === null) {
    //                         this.root = currentNode.left;
    //                     } else {
    //                         currentNode.right.left = currentNode.left;
    //
    //                         //if parent > current, make right child of the left the parent
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = currentNode.right;
    //
    //                             //if parent < current, make right child a right child of the parent
    //                         } else if (currentNode.value > parentNode.value) {
    //                             parentNode.right = currentNode.right;
    //                         }
    //                     }
    //
    //                     //Option 3: Right child that has a left child
    //                 } else {
    //
    //                     //find the Right child's left most child
    //                     let leftmost = currentNode.right.left;
    //                     let leftmostParent = currentNode.right;
    //                     while(leftmost.left !== null) {
    //                         leftmostParent = leftmost;
    //                         leftmost = leftmost.left;
    //                     }
    //
    //                     //Parent's left subtree is now leftmost right subtree
    //                     leftmostParent.left = leftmost.right;
    //                     leftmost.left = currentNode.left;
    //                     leftmost.right = currentNode.right;
    //
    //                     if(parentNode === null) {
    //                         this.root = leftmost;
    //                     } else {
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = leftmost;
    //                         } else if(currentNode.value > parentNode.value) {
    //                             parentNode.right = leftmost;
    //                         }
    //                     }
    //                 }
    //                 return true;
    //             }
    //         }
    //     }
    //     BreadthFirstSearch(){
    //         let currentNode = this.root;
    //         let list = [];
    //         let queue = [];
    //         queue.push(currentNode);
    //
    //         while(queue.length > 0){
    //             currentNode = queue.shift();
    //             list.push(currentNode.value);
    //             if(currentNode.left) {
    //                 queue.push(currentNode.left);
    //             }
    //             if(currentNode.right) {
    //                 queue.push(currentNode.right);
    //             }
    //         }
    //         return list;
    //     }
    //     BreadthFirstSearchR(queue, list) {
    //         if (!queue.length) {
    //             return list;
    //         }
    //         const currentNode = queue.shift();
    //         list.push(currentNode.value);
    //
    //         if (currentNode.left) {
    //             queue.push(currentNode.left);
    //         }
    //         if (currentNode.right) {
    //             queue.push(currentNode.right);
    //         }
    //
    //         return this.BreadthFirstSearchR(queue, list);
    //     }
    // }
    //
    // const tree = new BinarySearchTree();
    // tree.insert(9)
    // tree.insert(4)
    // tree.insert(6)
    // tree.insert(20)
    // tree.insert(170)
    // tree.insert(15)
    // tree.insert(1)
    //
    // console.log('BFS', tree.BreadthFirstSearch());
    // console.log('BFS', tree.BreadthFirstSearchR([tree.root], []))
    //
    // //     9
    // //  4     20
    // //1  6  15  170
    //
    // function traverse(node) {
    //     const tree = { value: node.value };
    //     tree.left = node.left === null ? null : traverse(node.left);
    //     tree.right = node.right === null ? null : traverse(node.right);
    //     return tree;
    // }

    // DFS code
    // InOder PreOrder PostOrder

    // class Node {
    //     constructor(value){
    //         this.left = null;
    //         this.right = null;
    //         this.value = value;
    //     }
    // }
    //
    // class BinarySearchTree {
    //     constructor(){
    //         this.root = null;
    //     }
    //     insert(value){
    //         const newNode = new Node(value);
    //         if (this.root === null) {
    //             this.root = newNode;
    //         } else {
    //             let currentNode = this.root;
    //             while(true){
    //                 if(value < currentNode.value){
    //                     //Left
    //                     if(!currentNode.left){
    //                         currentNode.left = newNode;
    //                         return this;
    //                     }
    //                     currentNode = currentNode.left;
    //                 } else {
    //                     //Right
    //                     if(!currentNode.right){
    //                         currentNode.right = newNode;
    //                         return this;
    //                     }
    //                     currentNode = currentNode.right;
    //                 }
    //             }
    //         }
    //     }
    //     lookup(value){
    //         if (!this.root) {
    //             return false;
    //         }
    //         let currentNode = this.root;
    //         while(currentNode){
    //             if(value < currentNode.value){
    //                 currentNode = currentNode.left;
    //             } else if(value > currentNode.value){
    //                 currentNode = currentNode.right;
    //             } else if (currentNode.value === value) {
    //                 return currentNode;
    //             }
    //         }
    //         return null
    //     }
    //     remove(value) {
    //         if (!this.root) {
    //             return false;
    //         }
    //         let currentNode = this.root;
    //         let parentNode = null;
    //         while(currentNode){
    //             if(value < currentNode.value){
    //                 parentNode = currentNode;
    //                 currentNode = currentNode.left;
    //             } else if(value > currentNode.value){
    //                 parentNode = currentNode;
    //                 currentNode = currentNode.right;
    //             } else if (currentNode.value === value) {
    //                 //We have a match, get to work!
    //
    //                 //Option 1: No right child:
    //                 if (currentNode.right === null) {
    //                     if (parentNode === null) {
    //                         this.root = currentNode.left;
    //                     } else {
    //
    //                         //if parent > current value, make current left child a child of parent
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = currentNode.left;
    //
    //                             //if parent < current value, make left child a right child of parent
    //                         } else if(currentNode.value > parentNode.value) {
    //                             parentNode.right = currentNode.left;
    //                         }
    //                     }
    //
    //                     //Option 2: Right child which doesnt have a left child
    //                 } else if (currentNode.right.left === null) {
    //                     if(parentNode === null) {
    //                         this.root = currentNode.left;
    //                     } else {
    //                         currentNode.right.left = currentNode.left;
    //
    //                         //if parent > current, make right child of the left the parent
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = currentNode.right;
    //
    //                             //if parent < current, make right child a right child of the parent
    //                         } else if (currentNode.value > parentNode.value) {
    //                             parentNode.right = currentNode.right;
    //                         }
    //                     }
    //
    //                     //Option 3: Right child that has a left child
    //                 } else {
    //
    //                     //find the Right child's left most child
    //                     let leftmost = currentNode.right.left;
    //                     let leftmostParent = currentNode.right;
    //                     while(leftmost.left !== null) {
    //                         leftmostParent = leftmost;
    //                         leftmost = leftmost.left;
    //                     }
    //
    //                     //Parent's left subtree is now leftmost's right subtree
    //                     leftmostParent.left = leftmost.right;
    //                     leftmost.left = currentNode.left;
    //                     leftmost.right = currentNode.right;
    //
    //                     if(parentNode === null) {
    //                         this.root = leftmost;
    //                     } else {
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = leftmost;
    //                         } else if(currentNode.value > parentNode.value) {
    //                             parentNode.right = leftmost;
    //                         }
    //                     }
    //                 }
    //                 return true;
    //             }
    //         }
    //     }
    //     BreadthFirstSearch(){
    //         let currentNode = this.root;
    //         let list = [];
    //         let queue = [];
    //         queue.push(currentNode);
    //
    //         while(queue.length > 0){
    //             currentNode = queue.shift();
    //             list.push(currentNode.value);
    //             if(currentNode.left) {
    //                 queue.push(currentNode.left);
    //             }
    //             if(currentNode.right) {
    //                 queue.push(currentNode.right);
    //             }
    //         }
    //         return list;
    //     }
    //     BreadthFirstSearchR(queue, list) {
    //         if (!queue.length) {
    //             return list;
    //         }
    //         const currentNode = queue.shift();
    //         list.push(currentNode.value);
    //
    //         if (currentNode.left) {
    //             queue.push(currentNode.left);
    //         }
    //         if (currentNode.right) {
    //             queue.push(currentNode.right);
    //         }
    //
    //         return this.BreadthFirstSearchR(queue, list);
    //     }
    //     DFTPreOrder(currentNode, list) {
    //         return traversePreOrder(this.root, []);
    //     }
    //     DFTPostOrder(){
    //         return traversePostOrder(this.root, []);
    //     }
    //     DFTInOrder(){
    //         return traverseInOrder(this.root, []);
    //     }
    // }
    //
    // function traversePreOrder(node, list){
    //     list.push(node.value);
    //     if(node.left) {
    //         traversePreOrder(node.left, list);
    //     }
    //     if(node.right) {
    //         traversePreOrder(node.right, list);
    //     }
    //     return list;
    // }
    //
    // function traverseInOrder(node, list){
    //     if(node.left) {
    //         traverseInOrder(node.left, list);
    //     }
    //     list.push(node.value);
    //     if(node.right) {
    //         traverseInOrder(node.right, list);
    //     }
    //     return list;
    // }
    //
    // function traversePostOrder(node, list){
    //     if(node.left) {
    //         traversePostOrder(node.left, list);
    //     }
    //     if(node.right) {
    //         traversePostOrder(node.right, list);
    //     }
    //     list.push(node.value);
    //     return list;
    // }
    //
    //
    // const tree = new BinarySearchTree();
    // tree.insert(9)
    // tree.insert(4)
    // tree.insert(6)
    // tree.insert(20)
    // tree.insert(170)
    // tree.insert(15)
    // tree.insert(1)
    // // tree.remove(170);
    // // JSON.stringify(traverse(tree.root))
    //
    // console.log('BFS', tree.BreadthFirstSearch());
    // console.log('BFS', tree.BreadthFirstSearchR([tree.root], []))
    // console.log('DFSpre', tree.DFTPreOrder());
    // console.log('DFSin', tree.DFTInOrder());
    // console.log('DFSpost', tree.DFTPostOrder());
    //
    // //     9
    // //  4     20
    // //1  6  15  170
    //
    // function traverse(node) {
    //     const tree = { value: node.value };
    //     tree.left = node.left === null ? null : traverse(node.left);
    //     tree.right = node.right === null ? null : traverse(node.right);
    //     return tree;
    // }

    // Dynamic Programming

    // the way cache things

    // simple way
    // function addTo80(n) {
    //     console.log("long Time")
    //     return n +80
    // }
    //     addTo80(5)

    // cache way


    // let  cache={
    //  5: 85    store value in cache when the function again call
    // we are not using cache globally so we use clousers functions
    // }


    //
    // function memoizedAddTo() {
    //     let cache = {};
    //     // use clousers
    //     return function (n) {
    //         if (n in cache) {
    //             return cache[n]
    //         } else {
    //             console.log("long time")
    //             cache[n] = n + 80
    //             return cache[n]
    //         }
    //     }
    //
    //
    // }
    //
    // const memoized = memoizedAddTo();
    // console.log('1', memoized(5))
    // console.log('2', memoized(5))


</script>

</body>
</html>