<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DSA</title>
</head>
<body>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semi-Circle Card</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }

        .card {
            position: relative;
            width: 300px;
            height: 150px;
            background-color: #3498db;
            border-radius: 15px; /* Adjust as needed */
            overflow: hidden;
        }

        .semi-circle-left,
        .semi-circle-right {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            background-color: #2c3e50;
            border-radius: 50%;
        }

        .semi-circle-left {
            left: -25%;
        }

        .semi-circle-right {
            right: -25%;
        }

        .content {
            padding: 20px;
            color: #ecf0f1;
            z-index: 1;
        }
    </style>
</head>

</html>
<script>
    // const nemo = ['dory', 'bruce', 'gill', 'nemo', 'gilly', 'billy', 'willey'];
    // const large = new Array(10000).fill('nemo')
    //
    // function findNemo(array) {
    //     let t0 = performance.now()
    //     for (let i = 0; i < array.length; i++) {
    //         if (array[i] === 'nemo') {
    //             console.log("Found Nemo!")
    //         }
    //     }
    //     let t1 = performance.now()
    //     console.log("Time: " + (t1 - t0) + " in milliseconds")
    // }
    //
    // findNemo(large)
    // O(n) --> Linear Time
    // O(n could be anything)
    // here O is the inputs nemo[1 or 10000]

    //   const compressAllBoxes = (boxes) => {
    //     boxes.forEach(box=>console.log(box))
    //   }
    // compressAllBoxes(['box'])

    // challenge

    // function funChallenge(input) {
    //     let a = 10;
    //     a= 50+3;
    //
    //     for (let i = 0; i < input.length; i++) {
    //         anotherFunction();
    //         let stranger =true;
    //         a++;
    //     }
    //     return a
    // }
    // funChallenge()

    // If condition is matched the we can use the break;
    // worst case: if the nemo is on the last
    //     const everyOne = ['dory', 'bruce', 'gill', 'nemo', 'gilly', 'billy', 'willey'];
    //     function findNemo(array) {
    //
    //         for (let i = 0; i < array.length; i++) {
    //             console.log("running")
    //             if (array[i] === 'nemo') {
    //                 console.log("Found Nemo!")
    //                 break;
    //             }
    //         }
    //     }
    //     findNemo(everyOne)

    // Rule: 2 Remove constants
    //  function printFirstItemThenFirstHalfThenSayHi100Times(items) {
    //      console.log(items[0]);
    //      let middleIndex=Math.floor(items.length/2)
    //      let index=0
    //      while (index<middleIndex){
    //          console.log(items[index])
    //          index++
    //      }
    //      for (let i = 0; i < 100; i++) {
    //          console.log('hi')
    //      }
    //  }

    //    Rule: 3
    //     const boxes=['a','b','c','d','e']
    //     function logAllPairsOfArray(array) {
    //         for (let i = 0; i < array.length; i++) {
    //             for (let j = 0; j < array.length; j++) {
    //                 console.log(array[i],array[j])
    //             }
    //
    //         }
    //     }
    //     logAllPairsOfArray(boxes)
    //    Rule 4

    // function printAllNumbersThenAllPairsSums(numbers) {
    //     console.log('These are the numbers')
    //     numbers.forEach(function (num){
    //         console.log(num)
    //     })
    //     console.log('and these are their sums')
    //     numbers.forEach(function (first) {
    //         numbers.forEach(function (second) {
    //             console.log(first+second)
    //         })
    //     })
    // }
    // printAllNumbersThenAllPairsSums([1,2,3,4,5])

    //    Space

    //     function space(n) {
    //         for (let i = 0; i < n.length; i++) {
    //             console.log("space...")
    //         }
    //     }
    //     space([1,2,3,4,5]) //0(1)


    //     function arrayOfN(n) {
    //         let hiArray=[];
    //         for (let i = 0; i < n; i++) {
    //             hiArray[i]="h1"
    //         }
    //         return hiArray;
    //     }
    // console.log(arrayOfN(500))

    //    Fun exercise working at twitter
    //
    // //    Find Ist, find Nth..
    // //     const array=['hi','my','teddy']
    //     // first and last
    //    // console.log(array[0]) ; // 0(1)
    //    // console.log(array.length-1)  // 0(1)
    //
    // //     if you find the date
    // const array=[
    //     {
    //         tweet:"Hi",
    //         date:2021
    //     },
    //     {
    //         tweet:"buddy",
    //         date:2022
    //     },
    //     {
    //         tweet:"oldest one",
    //         date:1982
    //     },
    // ]
    //    0(n^2)

    //    If we we string what is the length of in JS
    //    what is the Big(0) notation for this
    //    answer of the Big(0) depends on the language

    //    answer is 0(1)
    // let string ="string".length
    //     console.log(string)

    // Trees

    //  Binary Search trees

    // class based
    // class Node {
    //     constructor(value) {
    //         this.left = null;
    //         this.right = null;
    //         this.value = value;
    //     }
    // }
    //
    // class BinarySearchTree  {
    //     constructor() {
    //         this.root = null;
    //     }
    //
    //     insert(value) {
    //         const newNode = new Node(value)
    //         if (this.root === null) {
    //             this.root = newNode;
    //         } else {
    //             let currentNode = this.root;
    //             while (true) {
    //                 if (value < currentNode.value) {
    //                     // left
    //                     if (!currentNode.left) {
    //                         currentNode.left = newNode;
    //                         return this
    //                     }
    //                     currentNode = currentNode.left
    //                 } else {
    //                     // right
    //                     if (!currentNode.right) {
    //                         currentNode.right = newNode;
    //                         return this;
    //                     }
    //                     currentNode = currentNode.right;
    //                 }
    //             }
    //
    //         }
    //     }
    //
    //     lookup(value) {
    //         if (!this.root) {
    //             return false
    //         }
    //         let currentNode = this.root
    //         while (currentNode) {
    //             if (value < currentNode.value) {
    //                 currentNode = currentNode.left
    //             } else if (value > currentNode.value) {
    //                 currentNode = currentNode.right
    //             }else if(currentNode.value===value){
    //                 return currentNode
    //             }
    //         }
    //         return false
    //     }
    //     remove(value) {
    //         if (!this.root) {
    //             return false;
    //         }
    //         let currentNode = this.root;
    //         let parentNode = null;
    //         while(currentNode){
    //             if(value < currentNode.value){
    //                 parentNode = currentNode;
    //                 currentNode = currentNode.left;
    //             } else if(value > currentNode.value){
    //                 parentNode = currentNode;
    //                 currentNode = currentNode.right;
    //             } else if (currentNode.value === value) {
    //                 //We have a match, get to work!
    //
    //                 //Option 1: No right child:
    //                 if (currentNode.right === null) {
    //                     if (parentNode === null) {
    //                         this.root = currentNode.left;
    //                     } else {
    //
    //                         //if parent > current value, make current left child a child of parent
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = currentNode.left;
    //
    //                             //if parent < current value, make left child a right child of parent
    //                         } else if(currentNode.value > parentNode.value) {
    //                             parentNode.right = currentNode.left;
    //                         }
    //                     }
    //
    //                     //Option 2: Right child which doesnt have a left child
    //                 } else if (currentNode.right.left === null) {
    //                     currentNode.right.left = currentNode.left;
    //                     if(parentNode === null) {
    //                         this.root = currentNode.right;
    //                     } else {
    //
    //                         //if parent > current, make right child of the left the parent
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = currentNode.right;
    //
    //                             //if parent < current, make right child a right child of the parent
    //                         } else if (currentNode.value > parentNode.value) {
    //                             parentNode.right = currentNode.right;
    //                         }
    //                     }
    //
    //                     //Option 3: Right child that has a left child
    //                 } else {
    //
    //                     //find the Right child's left most child
    //                     let leftmost = currentNode.right.left;
    //                     let leftmostParent = currentNode.right;
    //                     while(leftmost.left !== null) {
    //                         leftmostParent = leftmost;
    //                         leftmost = leftmost.left;
    //                     }
    //
    //                     //Parent's left subtree is now left most's right subtree
    //                     leftmostParent.left = leftmost.right;
    //                     leftmost.left = currentNode.left;
    //                     leftmost.right = currentNode.right;
    //
    //                     if(parentNode === null) {
    //                         this.root = leftmost;
    //                     } else {
    //                         if(currentNode.value < parentNode.value) {
    //                             parentNode.left = leftmost;
    //                         } else if(currentNode.value > parentNode.value) {
    //                             parentNode.right = leftmost;
    //                         }
    //                     }
    //                 }
    //                 return true;
    //             }
    //         }
    //     }
    // }
    //
    // const tree = new BinarySearchTree();
    // tree.insert(9)
    // tree.insert(4)
    // tree.insert(6)
    // tree.insert(20)
    // tree.insert(170)
    // tree.insert(15)
    // tree.insert(1)
    // tree.remove(1)
    // console.log(tree.remove(19))
    //  console.log(JSON.stringify(traverse(tree.root)))
    //
    //
    // function traverse(node) {
    //     const tree = {value: node.value};
    //     tree.left = node.left === null ? null : traverse(node.left);
    //     tree.right = node.right === null ? null : traverse(node.right)
    //     return tree
    //
    // }

    // Priority Queue

    // GRAPH DS

    //     class Graph {
    //         constructor() {
    //             this.numberOfNodes = 0;
    //             this.adjacentList = {};
    //         }
    //         addVertex(node)  {
    //             this.adjacentList[node] = [];
    //             this.numberOfNodes++;
    //         }
    //         addEdge(node1, node2) {
    //             //undirected Graph
    //             this.adjacentList[node1].push(node2);
    //             this.adjacentList[node2].push(node1);
    //         }
    //         showConnections() {
    //             const allNodes = Object.keys(this.adjacentList);
    //             for (let node of allNodes) {
    //                 let nodeConnections = this.adjacentList[node];
    //                 let connections = "";
    //                 let vertex;
    //                 for (vertex of nodeConnections) {
    //                     connections += vertex + " ";
    //                 }
    //                 console.log(node + "-->" + connections);
    //             }
    //         }
    //     }
    //
    //     const myGraph = new Graph();
    //     myGraph.addVertex('0');
    //     myGraph.addVertex('1');
    //     myGraph.addVertex('2');
    //     myGraph.addVertex('3');
    //     myGraph.addVertex('4');
    //     myGraph.addVertex('5');
    //     myGraph.addVertex('6');
    //     myGraph.addEdge('3', '1');
    //     myGraph.addEdge('3', '4');
    //     myGraph.addEdge('4', '2');
    //     myGraph.addEdge('4', '5');
    //     myGraph.addEdge('1', '2');
    //     myGraph.addEdge('1', '0');
    //     myGraph.addEdge('0', '2');
    //     myGraph.addEdge('6', '5');
    // console.log(myGraph)
    //     myGraph.showConnections();


    //    **** Algorithms   **** //

    // Recursion

    // Anatomy of recursion
    // base case  needs to stop the function

    // let counter = 0;
    //
    // function inception() {
    //     console.log(counter)
    //     if (counter > 3) {
    //         return "done"
    //     }
    //     counter++
    //     return inception()
    //
    // }
    // console.log(inception())

    // write two functions finds the factorial of any number.


    // factorial

    //     function findFactorialRecursive(number) {
    // if (number===2){
    //     return 2
    // }
    // return number * findFactorialRecursive(4)
    //     }
    // console.log(findFactorialRecursive(5))
    //     function findFactorialIterative(number) {
    //         let answer = 1;
    //         if (number===2){
    //             answer = 2;
    //         }
    //         for (let i = 2; i <= number; i++) {
    // answer = answer *i;
    //         }
    //         return answer
    //     }
    //     console.log(findFactorialIterative(5))


    //  fibonacci
    // Given a number N return the index value of the Fibonacci sequence, where sequence is:

    // 0,1,1,2,3,5,8,13,21,34,55,89,144...
    // the pattern of the sequence is that each value is the sum of the 2 previous values. that
    // means that for N=5 -> 2+3

    // function fibonacciIterative(n) { // 0(n)
    //     let arr = [0, 1];
    //     for (let i = 2; i < n + 1; i++) {
    //         arr.push(arr[i - 2] + arr[i - 1])
    //     }
    //     return arr[n]
    // }
    //
    // console.log(fibonacciIterative(52))
    //
    // function fibonacciRecursive(n) {//0(2^n) vey bad Big )
    //     if (n < 2) {
    //         return n;
    //     }
    //     return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2)
    // }
    //
    // console.log(fibonacciRecursive(5))

    //Implement a function that reverses a string using iteration...and then recursion!
    // function reverseString(str) {
    //
    //     return str.split("").reverse().join("")
    //
    // }
    //
    // console.log(reverseString('yoyo mastery'))
    // //should return: 'yretsam oyoy'
    //
    // function reverseStringRecursive(str) {
    //     if (str === "") {
    //         return "";
    //     } else {
    //         return reverseStringRecursive(str.substr(1)) + str.charAt(0);
    //     }
    // }
    // reverseStringRecursive('yoyo master');


    // ****** Sorting*****

    // Bubble Sort

    //     const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0]
    //
    //     function bubbleSort(arr) {
    //         for (let i = 0; i < arr.length; i++) {
    //             for (let j = 0; j < arr.length; j++) {
    //
    //                     if (arr[j] > arr[j+1]){
    //                         // swap numbers
    //                         let temp = arr[j];
    //                         arr[j]= arr[j+1];
    //                         arr[j+1]=temp
    //                     }
    //
    //             }
    //         }
    //     }
    // bubbleSort(numbers)
    // console.log(numbers)

    // Selection sort

    // const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0]
    //
    // function selectionSort(array) {
    //     const length = array.length;
    //
    //     for (let i = 0; i < length; i++) {
    //      // set current index as minimum
    //         let min = i;
    //         let temp = array[i];
    //         for (let j = i + 1; j < length; j++) {
    //             if (array[j] < array[min]) {
    //                 min = j
    //             }
    //         }
    //         array[i] = array[min]
    //         array[min] = temp
    //     }
    //     return array
    // }
    //
    // selectionSort(numbers)
    // console.log(numbers)


    // Insertion sort

    // const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0]
    //
    // function InsertionSort(array) {
    //     const length = array.length;
    //     for (let i = 0; i < length; i++) {
    //         if (array[i] < array[0]) {
    //             // move number to the first position
    //             array.unshift(array.splice(i, 1)[0]);
    //         } else {
    //             // find where number should go
    //             for (let j = 0; j < i; j++) {
    //                 if (array[i] > array[j - 1] && array[i] < array[j]) {
    //                     // move number to the right spot
    //                     array.splice(j, 0, array.splice(i, 1)[0]);
    //                 }
    //             }
    //         }
    //     }
    // }
    //
    // InsertionSort(numbers)
    // console.log(numbers)

    // Merge Sort
    // const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0]
    //
    // function mergeSort(array) {
    //     if (array.length <= 1) {
    //         return array;
    //     }
    //
    //     const middleIndex = Math.floor(array.length / 2);
    //     const left = array.slice(0, middleIndex);
    //     const right = array.slice(middleIndex);
    //
    //     // console.log("left", left)
    //     // console.log("right", right)
    //
    //     return merge(
    //         mergeSort(left),
    //         mergeSort(right)
    //     );
    // }
    //
    // function merge(left, right) {
    //     const mergedArray = [];
    //     let leftIndex = 0;
    //     let rightIndex = 0;
    //
    //     while (leftIndex < left.length && rightIndex < right.length) {
    //         if (left[leftIndex] <= right[rightIndex]) {
    //             mergedArray.push(left[leftIndex]);
    //             leftIndex++;
    //         } else {
    //             mergedArray.push(right[rightIndex]);
    //             rightIndex++;
    //         }
    //     }
// GPT
        // Add any remaining elements from the left and right sub-arrays
        // while (leftIndex < left.length) {
        //     mergedArray.push(left[leftIndex]);
        //     leftIndex++;
        // }
        //
        // while (rightIndex < right.length) {
        //     mergedArray.push(right[rightIndex]);
        //     rightIndex++;
        // }
    //     console.log("left", left)
    //     console.log("right", right)
    //     return mergedArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
    // }
    //
    // console.log(mergeSort(numbers))


    // Quick Sort

    // const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];
    //
    // function quickSort(array, left, right){
    //     let pivot;
    //     let partitionIndex;
    //
    //     if(left < right) {
    //         pivot = right;
    //         partitionIndex = partition(array, pivot, left, right);
    //
    //         //sort left and right
    //         quickSort(array, left, partitionIndex - 1);
    //         quickSort(array, partitionIndex + 1, right);
    //     }
    //     return array;
    // }
    //
    // function partition(array, pivot, left, right){
    //     let pivotValue = array[pivot];
    //     let partitionIndex = left;
    //
    //     for(let i = left; i < right; i++) {
    //         if(array[i] < pivotValue){
    //             swap(array, i, partitionIndex);
    //             partitionIndex++;
    //         }
    //     }
    //     swap(array, right, partitionIndex);
    //     return partitionIndex;
    // }
    //
    // function swap(array, firstIndex, secondIndex){
    //     let temp = array[firstIndex];
    //     array[firstIndex] = array[secondIndex];
    //     array[secondIndex] = temp;
    // }
    //
    // //Select first and last index as 2nd and 3rd parameters
    // quickSort(numbers, 0, numbers.length - 1);
    // console.log(numbers);


    // ***** Algorithms: Searching + Transversal  ******

//    Linear Search

</script>
</body>
</html>